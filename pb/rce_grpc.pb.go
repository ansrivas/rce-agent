// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// RCEAgentClient is the client API for RCEAgent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RCEAgentClient interface {
	// Start a command and immediately return its ID. Be sure to call Wait or Stop
	// to reap the command, else the agent will effectively leak memory by holding
	// unreaped commands. A command is considered running until reaped.
	Start(ctx context.Context, in *Command, opts ...grpc.CallOption) (*ID, error)
	// Wait for a command to complete or be stopped, reap it, and return its final status.
	Wait(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error)
	// Get the status of a command if it hasn't been reaped by calling Wait or Stop.
	GetStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error)
	// Stop then reap a command by sending it a SIGTERM signal.
	Stop(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	// Return a list of all running (not reaped) commands by ID.
	Running(ctx context.Context, in *Empty, opts ...grpc.CallOption) (RCEAgent_RunningClient, error)
	// Return a list of all available commands
	ListCommands(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCommandsResponse, error)
}

type rCEAgentClient struct {
	cc grpc.ClientConnInterface
}

func NewRCEAgentClient(cc grpc.ClientConnInterface) RCEAgentClient {
	return &rCEAgentClient{cc}
}

var rCEAgentStartStreamDesc = &grpc.StreamDesc{
	StreamName: "Start",
}

func (c *rCEAgentClient) Start(ctx context.Context, in *Command, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/rce.RCEAgent/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var rCEAgentWaitStreamDesc = &grpc.StreamDesc{
	StreamName: "Wait",
}

func (c *rCEAgentClient) Wait(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/rce.RCEAgent/Wait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var rCEAgentGetStatusStreamDesc = &grpc.StreamDesc{
	StreamName: "GetStatus",
}

func (c *rCEAgentClient) GetStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/rce.RCEAgent/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var rCEAgentStopStreamDesc = &grpc.StreamDesc{
	StreamName: "Stop",
}

func (c *rCEAgentClient) Stop(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rce.RCEAgent/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var rCEAgentRunningStreamDesc = &grpc.StreamDesc{
	StreamName:    "Running",
	ServerStreams: true,
}

func (c *rCEAgentClient) Running(ctx context.Context, in *Empty, opts ...grpc.CallOption) (RCEAgent_RunningClient, error) {
	stream, err := c.cc.NewStream(ctx, rCEAgentRunningStreamDesc, "/rce.RCEAgent/Running", opts...)
	if err != nil {
		return nil, err
	}
	x := &rCEAgentRunningClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RCEAgent_RunningClient interface {
	Recv() (*ID, error)
	grpc.ClientStream
}

type rCEAgentRunningClient struct {
	grpc.ClientStream
}

func (x *rCEAgentRunningClient) Recv() (*ID, error) {
	m := new(ID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var rCEAgentListCommandsStreamDesc = &grpc.StreamDesc{
	StreamName: "ListCommands",
}

func (c *rCEAgentClient) ListCommands(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCommandsResponse, error) {
	out := new(ListCommandsResponse)
	err := c.cc.Invoke(ctx, "/rce.RCEAgent/ListCommands", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RCEAgentService is the service API for RCEAgent service.
// Fields should be assigned to their respective handler implementations only before
// RegisterRCEAgentService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type RCEAgentService struct {
	// Start a command and immediately return its ID. Be sure to call Wait or Stop
	// to reap the command, else the agent will effectively leak memory by holding
	// unreaped commands. A command is considered running until reaped.
	Start func(context.Context, *Command) (*ID, error)
	// Wait for a command to complete or be stopped, reap it, and return its final status.
	Wait func(context.Context, *ID) (*Status, error)
	// Get the status of a command if it hasn't been reaped by calling Wait or Stop.
	GetStatus func(context.Context, *ID) (*Status, error)
	// Stop then reap a command by sending it a SIGTERM signal.
	Stop func(context.Context, *ID) (*Empty, error)
	// Return a list of all running (not reaped) commands by ID.
	Running func(*Empty, RCEAgent_RunningServer) error
	// Return a list of all available commands
	ListCommands func(context.Context, *Empty) (*ListCommandsResponse, error)
}

func (s *RCEAgentService) start(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/rce.RCEAgent/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Start(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *RCEAgentService) wait(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/rce.RCEAgent/Wait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Wait(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *RCEAgentService) getStatus(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/rce.RCEAgent/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetStatus(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *RCEAgentService) stop(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/rce.RCEAgent/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Stop(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *RCEAgentService) running(_ interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.Running(m, &rCEAgentRunningServer{stream})
}
func (s *RCEAgentService) listCommands(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/rce.RCEAgent/ListCommands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListCommands(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

type RCEAgent_RunningServer interface {
	Send(*ID) error
	grpc.ServerStream
}

type rCEAgentRunningServer struct {
	grpc.ServerStream
}

func (x *rCEAgentRunningServer) Send(m *ID) error {
	return x.ServerStream.SendMsg(m)
}

// RegisterRCEAgentService registers a service implementation with a gRPC server.
func RegisterRCEAgentService(s grpc.ServiceRegistrar, srv *RCEAgentService) {
	srvCopy := *srv
	if srvCopy.Start == nil {
		srvCopy.Start = func(context.Context, *Command) (*ID, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
		}
	}
	if srvCopy.Wait == nil {
		srvCopy.Wait = func(context.Context, *ID) (*Status, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
		}
	}
	if srvCopy.GetStatus == nil {
		srvCopy.GetStatus = func(context.Context, *ID) (*Status, error) {
			return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
		}
	}
	if srvCopy.Stop == nil {
		srvCopy.Stop = func(context.Context, *ID) (*Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
		}
	}
	if srvCopy.Running == nil {
		srvCopy.Running = func(*Empty, RCEAgent_RunningServer) error {
			return status.Errorf(codes.Unimplemented, "method Running not implemented")
		}
	}
	if srvCopy.ListCommands == nil {
		srvCopy.ListCommands = func(context.Context, *Empty) (*ListCommandsResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListCommands not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "rce.RCEAgent",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "Start",
				Handler:    srvCopy.start,
			},
			{
				MethodName: "Wait",
				Handler:    srvCopy.wait,
			},
			{
				MethodName: "GetStatus",
				Handler:    srvCopy.getStatus,
			},
			{
				MethodName: "Stop",
				Handler:    srvCopy.stop,
			},
			{
				MethodName: "ListCommands",
				Handler:    srvCopy.listCommands,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "Running",
				Handler:       srvCopy.running,
				ServerStreams: true,
			},
		},
		Metadata: "rce.proto",
	}

	s.RegisterService(&sd, nil)
}

// NewRCEAgentService creates a new RCEAgentService containing the
// implemented methods of the RCEAgent service in s.  Any unimplemented
// methods will result in the gRPC server returning an UNIMPLEMENTED status to the client.
// This includes situations where the method handler is misspelled or has the wrong
// signature.  For this reason, this function should be used with great care and
// is not recommended to be used by most users.
func NewRCEAgentService(s interface{}) *RCEAgentService {
	ns := &RCEAgentService{}
	if h, ok := s.(interface {
		Start(context.Context, *Command) (*ID, error)
	}); ok {
		ns.Start = h.Start
	}
	if h, ok := s.(interface {
		Wait(context.Context, *ID) (*Status, error)
	}); ok {
		ns.Wait = h.Wait
	}
	if h, ok := s.(interface {
		GetStatus(context.Context, *ID) (*Status, error)
	}); ok {
		ns.GetStatus = h.GetStatus
	}
	if h, ok := s.(interface {
		Stop(context.Context, *ID) (*Empty, error)
	}); ok {
		ns.Stop = h.Stop
	}
	if h, ok := s.(interface {
		Running(*Empty, RCEAgent_RunningServer) error
	}); ok {
		ns.Running = h.Running
	}
	if h, ok := s.(interface {
		ListCommands(context.Context, *Empty) (*ListCommandsResponse, error)
	}); ok {
		ns.ListCommands = h.ListCommands
	}
	return ns
}

// UnstableRCEAgentService is the service API for RCEAgent service.
// New methods may be added to this interface if they are added to the service
// definition, which is not a backward-compatible change.  For this reason,
// use of this type is not recommended.
type UnstableRCEAgentService interface {
	// Start a command and immediately return its ID. Be sure to call Wait or Stop
	// to reap the command, else the agent will effectively leak memory by holding
	// unreaped commands. A command is considered running until reaped.
	Start(context.Context, *Command) (*ID, error)
	// Wait for a command to complete or be stopped, reap it, and return its final status.
	Wait(context.Context, *ID) (*Status, error)
	// Get the status of a command if it hasn't been reaped by calling Wait or Stop.
	GetStatus(context.Context, *ID) (*Status, error)
	// Stop then reap a command by sending it a SIGTERM signal.
	Stop(context.Context, *ID) (*Empty, error)
	// Return a list of all running (not reaped) commands by ID.
	Running(*Empty, RCEAgent_RunningServer) error
	// Return a list of all available commands
	ListCommands(context.Context, *Empty) (*ListCommandsResponse, error)
}
